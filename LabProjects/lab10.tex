\chapter*{Лабораторная работа 10. Ограничение количества соединений}
\addcontentsline{toc}{chapter}{Лабораторная работа 10. Ограничение количества соединений}

\textbf{Цель работы:} Исследовать средства ограничения количества соединений к серверу с клиентских компьютеров.

\section*{Введение}
\addcontentsline{toc}{section}{Введение}

Linux, как и все операционные системы общего назначения, работает с максимальной эффективностью. Это означает, что, как правило, пока есть доступные ресурсы, приложения могут их запрашивать. С другой стороны, если какой-то пул ресурсов истощается, это может повлиять на работоспособность и скорость отклика всей системы.

Таким образом, даже если теоретически Linux не должен ограничивать использование ресурсов до пределов аппаратного обеспечения, на практике должен. Многие атаки типа "отказ в обслуживании" (DoS) работают пытаясь истощить целевые ресурсы. Чтобы избежать серьезных последствий, в любой современной операционной системе по умолчанию действуют политики использования ресурсов. Администратору может потребоваться настроить политики ограничения в соответствии с их вариантами использования. Кроме того, значения по умолчанию обычно подходят для общего использования.

Существует множество средств контроля безопасности, обеспечивающих стабильность и быстродействие системы.

\section*{1. Файловые дескрипторы}
\addcontentsline{toc}{section}{1. Файловые дескрипторы}

Способ, которым Linux и другие операционные системы на основе POSIX взаимодействуют между процессами, называется межпроцессным взаимодействием или IPC. Одна из прелестей этой концепции заключается в том, что она применима к связи между процессами на одном хосте или через сеть компьютеров. Это означает, что оба сценария имеют общую основу для базовых API.

Если у нас есть две программы на одном хосте, которые общаются друг с другом с помощью Sockets API (стандарт де-факто для потоковой передачи данных в POSIX), их преобразование для работы на разных серверах потребует минимальных изменений. Следовательно, ядро предоставляет конечные точки связи в аналогичных формах.

Стоит заметить, что Sockets IPC API, используемый в Linux TCP/IP-соединениях, использует файловые дескрипторы. Таким образом, количество открытых файловых дескрипторов является одним из первых ограничений, с которыми можно столкнуться. Это относится как к сокетам TCP, так и к UDP.

\subsection*{1.1 Ограничения файловых дескрипторов на уровне ядра}
\addcontentsline{toc}{subsection}{1.1 Ограничения файловых дескрипторов на уровне ядра}

Значения уровня ядра применимы ко всей системы. Количество доступных дескрипторов содержится в \texttt{/proc/sys/fs/file-max}.

\begin{Verbatim}[frame=single]
    user@ubuntu$ cat /proc/sys/fs/file-max
    9223372036854775807
\end{Verbatim}

Это огромное число используется по умолчанию во многих дистрибутивах. Чтобы изменить это ограничение, мы можем установить его на лету с помощью команды \texttt{sysctl}.

\begin{Verbatim}[frame=single]
    user@ubuntu$ sudo sysctl fs.file-max=65536
    [sudo] password for user: 
    fs.file-max = 65536
\end{Verbatim}

Мы ограничили количество дескрипторов до первой перезагрузки. Чтобы сделать эти изменения постоянными, нужно добавить запись в файл \texttt{/etc/sysctl.conf}, где можно установить постоянные настройки настройки записав строчку:

\texttt{fs.file-max=65536  \# Ограничение количества открытых дескрипторов (файлов)}

Всякий раз, когда предел будет достигнут, система выдаст событие "Слишком много открытых файлов в системе". Текущее использование дескриптором можно увидеть следующим образом:

\begin{Verbatim}[frame=single]
    user@ubuntu$ cat /proc/sys/fs/file-nr
    6592	0	65536
\end{Verbatim}

Здесь мы видим три числа:
\begin{itemize}
    \item текущее число используемых файловых дескрипторов;
    \item выделенное, но неиспользуемое число (всегда 0);
    \item максимальное число (то же, что и \texttt{fs.file-max})
\end{itemize}

Наряду с общесистемным ограничением, ядро Linux налагает ограничения файлового дескриптора на каждый процесс. Это настраивается с помощью параметра \texttt{fs.nr\_open}. Значение по умолчанию -- \texttt{1048576} (снова довольно высокое значение).

\subsection*{1.2 Ограничения дескрипторов на уровне пользователя}
\addcontentsline{toc}{subsection}{1.2 Ограничения дескрипторов на уровне пользователя}

Фактические ограничения накладываются оболочкой (shell) на пользовательском уровне. Каждый экземпляр оболочки устанавливает гораздо более строгий предел -- по умолчанию 1024 открытых файла.

Этот лимит более чем подходит для обычных пользователей. Однако для серверных приложений он, скорее всего, достаточно низкий. Например, большие серверы баз данных могут иметь тысячи файлов данных и открытых соединений.

Этими ограничениями можно управлять с помощью команды \texttt{ulimit} и сохранять их, редактируя файл \texttt{/etc/security/limits.conf}. Например, чтобы изменить ограничение процесса \texttt{Oracle} на \texttt{8192}, нужно добавить в файл эту строку:

\fbox{
    \parbox{\textwidth}{%
    \texttt{\noindent
    \#<domain>      <type>  <item>         <value>\\
    oracle          hard    nofile         8192
    }}%
}

Ключевое слово \texttt{hard} означает, что непривилегированные пользователи не могут изменять ограничение в любой момент. Мягкое ограничение позволит пользователю без полномочий root использовать команду \texttt{ulimit}, чтобы изменить его для определенных случаев использования.

\section*{2. Процессы и потоки}
\addcontentsline{toc}{section}{2. Процессы и потоки}

Как и в случае с ограничением не количество файловых дескприпторов, существуют ограничения как ядра, так и пользовательского пространства на количество процессов и потоков. В серверных приложениях мы обычно назначаем соединения рабочим процессам (workers). Таким образом, их ограничения могут ограничивать количество соединений, которые они могут обрабатывать.

Для процессов ограничивающими параметрами являются:
\begin{itemize}
    \item Пространство ядра: \texttt{kernel.pid\_max}. По умолчанию \texttt{32767} и управляет общесистемным размером таблицы процессов.
    \item Пространство пользователя: \texttt{ulimit -u} или параметр \texttt{nproc} в \texttt{limit.conf}. Максимальное количество пользовательских процессов \texttt{15397}.
\end{itemize}

И, для потоков:
\begin{itemize}
    \item Пространство ядра: \texttt{kernel.threads-max}. Максимальное количество потоков, которые может создать системный вызов \texttt{fork}. Его можно уменьшить в реальном времени, когда таблица процессов достигает 1/8 оперативной памяти системы.
    \item Пространство пользователя: \texttt{общая виртуальная память / (размер стека * 1024 * 1024)}. Размер стека контролируется с помощью \texttt{ulimit -s} или элемента \texttt{stack} в \texttt{limit.conf}.
\end{itemize}

\section*{3. Параметры сетевого стека}
\addcontentsline{toc}{section}{3. Параметры сетевого стека}

Существуют параметры ядра, которые могут косвенно влиять на количество TCP-соединений. TCP имеет довольно сложный конечный автомат и ядро должно отслеживать каждое состояние соединения (тайминги и переходы). Кроме управляющих таблиц TCP, можно рассмотреть настройки Netfilter, которые так же могут влиять на ограничение TCP-соединений.

Для Netfilter:
\begin{itemize}
    \item \texttt{net.netfilter.nf\_conntrack\_max}: максимальное количество подключений для отслеживания.
    \item \texttt{nf\_conntrack\_tcp\_timeout\_*}: ограничивает тайм-аут для каждого состояния TCP-соединения(отправка/получение SYN, ожидание закрытия, прочие таймауты)
\end{itemize}

Для стека TCP:
\begin{itemize}
    \item \texttt{net.core.netdev\_max\_backlog}: максимальное количество пакетов в очереди на стороне получения, когда интерфейс получает пакеты быстрее, чем ядро может их обработать
    \item \texttt{net.ipv4.ip\_local\_port\_range}: виртуальный диапазон портов (порты, динамически выделяемые на клиентской стороне соединений TCP).
    \item \texttt{net.ipv4.somaxconn}: размер очереди установленных соединений ожидающих обработки \texttt{accept()}.
    \item \texttt{net.ipv4.tcp\_fin\_timeout}: время, в течение которого потерянное соединение будет ждать, прежде чем оно будет прервано (состояние \texttt{TIME\_WAIT})
    \item \texttt{net.ipv4.tcp\_tw\_reuse}: позволяет повторно использовать сокеты с ожиданием времени для новых подключений, экономит ресурсы при высоких скоростях создания и уничтожения соединений.
    \item \texttt{net.ipv4.tcp\_max\_orphans}: максимальное количество сокетов TCP, не прикрепленных к дескриптору файла.
    \item \texttt{net.ipv4.tcp\_max\_syn\_backlog}: максимальное количество запомненных запросов на подключение (\texttt{SYN\_RECV}), которые не получили подтверждения от подключающегося клиента.
    \item \texttt{net.ipv4.tcp\_max\_tw\_buckets}: Максимальное число сокетов, находящихся в состоянии \texttt{TIME-WAIT} одновременно.
\end{itemize}

Некоторые другие полезные параметры можно найти по ссылкам:
\begin{itemize}
    \item \hyperlink{https://www.opennet.ru/docs/RUS/LARTC/x1727.html}{Малоизвестные настройки (opennet.ru)}
    \item \hyperlink{https://habr.com/ru/company/otus/blog/340870/}{Сказ о sysctl (habr.com)}
\end{itemize}

Значение по умолчанию для этих параметров подходит для многих приложений. Как и другие параметры ядра, их значения можно установить с помощью команды \texttt{sysctl}, а сохранить изменения можно с используя файл \texttt{/etc/sysctl.conf}.

\section*{4. Ограничения IP Tables}
\addcontentsline{toc}{section}{4. Ограничения IP Tables}

В предыдущих работах мы уже отмечали, что можем использовать ip tables для назначения лимитов соединений. Мы можем установить ограничения на основе исходных адресов, портов назначения и многих других параметров. При этом используются модуль \texttt{connlimit} (или более новый \texttt{hashlimit}) ip tables.

Например, чтобы ограничить SSH-подключения до трёх на один IP-адрес, можно использовать:

\texttt{iptables --append INPUT --protocol tcp --syn --dport 22 --match connlimit --connlimit-above 3 --jump REJECT}

Где \texttt{--syn} позволяет пропускать пакеты TCP с установленным флагом SYN и снятыми ACK,RST,FIN. Такие пакеты используются для запроса создания TCP-соединения. Очевидно, блокирование таких пакетов приведёт к невозможности создания входящих TCP-соединений.

На практике лучше избегать такой подход и по возможности использовать соответствующий функционал в приложении, чтобы не грузить файрволл в ядре stateful вычислениями.

\section*{5. Ограничения запросов на уровне приложений}
\addcontentsline{toc}{section}{5. Ограничения запросов на уровне приложений}

Веб-сервер NGINX имеет различные модули, позволяющие контролировать конечный трафик на свои веб-сайты, веб-приложения и другие ресурсы. Одной из основных причин ограничения трафика или доступа является предотвращение злоупотреблений или атак определенных видов, таких как DoS-атаки (отказ в обслуживании).

Существует три основных способа ограничения использования или трафика в NGINX:
\begin{itemize}
    \item Ограничение количества подключений (запросов).
    \item Ограничение скорости запросов.
    \item Ограничение пропускного канала.
\end{itemize}

Эти подходы к управлению трафиком, могут быть настроены для ограничения на основе определенного ключа. Наиболее распространенным ключом которых является IP-адрес клиента, но также поддерживаются другие переменные, такие как cookie-файл, сеанс, и многие другие.

\subsection*{5.1 Ограничение количества подключений (запросов)}
\addcontentsline{toc}{subsection}{5.1 Ограничение количества подключений (запросов)}

\subsection*{5.2 Ограничение скорости запросов}
\addcontentsline{toc}{subsection}{5.2 Ограничение скорости запросов}


\subsection*{5.3 Ограничение пропускного канала}
\addcontentsline{toc}{subsection}{5.3 Ограничение пропускного канала}


\section*{Выводы}
\addcontentsline{toc}{section}{Выводы}

