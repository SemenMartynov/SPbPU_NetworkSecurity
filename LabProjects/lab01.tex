\chapter*{Лабораторная работа 1. Сокетные соединения}
\addcontentsline{toc}{chapter}{Лабораторная работа 1. Сокетные соединения}

\textbf{Цель работы:} Освоение набора системных вызовов для создания сокетных соединений различных типов, для обмена данными на хостах и по сети.

\section*{1. Системные вызовы}
\addcontentsline{toc}{section}{1. Системные вызовы}
\textbf{Задача:} Проанализируйте набор системных вызовов для серверной и клиентской сторон при организации соединений на сокетах под ОС Linux, принимая во внимание возможности различных видов сокетов и семейств адресации.

\textbf{Ход решения:}

Основные вызовы:
\begin{itemize}
    \item \texttt{socket()} -- создать новый сокет и вернуть файловый дескриптор;
    \item \texttt{send()} -- отправить данные по сети;
    \item \texttt{receive()} -- получить данные из сети;
    \item \texttt{close()} -- закрыть соединение.
\end{itemize}

Основные вызовы на стороне сервера:
\begin{itemize}
    \item \texttt{bind()} -- связать сокет с IP-адресом и портом;
    \item \texttt{listen()} -- слушает порт и ждет когда будет установлено соединение;
    \item \texttt{accept()} -- принять запрос на установку соединения.
\end{itemize}

Основные вызовы на стороне клиента:
\begin{itemize}
    \item \texttt{connect()} -- установить соединение.
\end{itemize}

Основные семейства протоколов создаваемого сокета:
\begin{itemize}
    \item \texttt{AF\_INET} -- для сетевого протокола IPv4;
    \item \texttt{AF\_INET6} -- для IPv6;
    \item \texttt{AF\_UNIX} -- для локальных сокетов (используя файл).
\end{itemize}

Основные типы соединений:
\begin{itemize}
    \item \texttt{SOCK\_STREAM} -- надёжная потокоориентированная служба или потоковый сокет;
    \item \texttt{SOCK\_DGRAM} -- служба датаграмм или датаграммный сокет;
    \item \texttt{SOCK\_RAW} -- сырой протокол поверх сетевого уровня.
\end{itemize}

\section*{2. Присоединенные сокеты}
\addcontentsline{toc}{section}{2. Присоединенные сокеты}
\textbf{Задача:} Скомпилируйте и выполните программу \texttt{socketpair.cpp}, иллюстрирующую создание простейшего вида сокета и обмен данными двух родственных процессов.

Проанализируйте вывод на консоль. Существует ли зависимость обмена от различных соотношений величин временных задержек (в вызовах \texttt{sleep()}) в процессе-родителе и в процессе-потомке?

\textbf{Ход решения:} Беглый анализ исходного текста позволяет выявить следующие моменты:
\begin{enumerate}
    \item{В цикле \texttt{switch} дан не правильный комментарий для поведения по умолчанию: там сказано, что дальнейший код будет исполняться потомком, хотя это не так. Системный вызов \texttt{fork()} возвращает положительное не нулевое число для процесса-родителя.}
    \item{Для организации сетевого взаимодействия используется системный вызов \texttt{socketpair()}, который создает пару безымянных присоединённых сокетов. Рассмотрим параметры, которые используются для этого системного вызова:
                \begin{itemize}
                    \item \texttt{PF\_UNIX} показывает, что будет использовано локальное соединение.
                    \item \texttt{SOCK\_STREAM} показывает, что семантика коммуникации обеспечивает создание двусторонних надежных и последовательных потоков байтов, поддерживающих соединения.
                \end{itemize}
                Остальные параметры тривиальны.
          }
    \item{Учитывая, что потомок всегда пишет, и только потом читает, а предок действует наоборот, и при этом у нас блокирующие операции, сразу понятно, что будет простой поочерёдный обмен, и вызов \texttt{sleep()} ни на что не влияет. Или, другими словами, каждый этот вызов будет влиять и на одну и на другую сторону общения, увеличивая их ожидание.}
\end{enumerate}

\textbf{Эксперимент:} Запустив приложение, мы получили следующий вывод:
\begin{Verbatim}[frame=single,breaklines=true,breakanywhere=true]
    smart@thinkpad$ ./socketpair
    p->c:0
    c->p: 1
    p->c:2
    c->p: 3
    p->c:4
    c->p: 5
    p->c:6
    c->p: 7
    p->c:8
    c->p: 9
\end{Verbatim}

Дальнейшие эксперименты с \texttt{sleep()} подтвердили изначальные гипотезы: можно полностью убрать оба вызова \texttt{sleep()} и это не сломает программу, можно увеличивать значение параметра для \texttt{sleep()} и это будет влиять на оба процесса.

\section*{3. Локальные сокеты}
\addcontentsline{toc}{section}{3. Локальные сокеты}
\textbf{Задача:} Скомпилируйте программы \texttt{echo\_server.cpp} и \texttt{echo\_client.cpp}, задавая им при компиляции разные имена.

Запустите программы сервера и клиента на разных терминалах. Введите символьную информацию в окне клиента и проанализируйте вывод. Какой разновидности принадлежат сокеты, используемые в данном примере клиент-серверного взаимодействия?

С чем связано создание специального файла в текущем каталоге во время исполнения программ?

\textbf{Ход решения:} Начнём с анализа исходных кодов.

Сервер:
\begin{enumerate}
\item Создаётся сокет, используя системный вызов \texttt{socket()}. Параметры \texttt{AF\_UNIX} и \texttt{SOCK\_STREAM} идентичны параметрам из предыдущего шага (\texttt{AF\_UNIX} это синоним для \texttt{PF\_UNIX}). Фактический результат этого вызова -- файловый дескриптор.
\item Для соединения (\texttt{bind()}) сокета с адресом (\texttt{sockaddr\_un}), производится подготовка этого адреса. Обычно тут задаётся адрес хоста и номер порта для ожидания соединения, но в данном случае адресу задаётся семейство, идентичное семейству сокета (\texttt{AF\_UNIX}) и указывается путь, где сокет будет располагаться в файловой системе. Вызов (\texttt{unlink()}) позволяет автоматически удалить файл сокета, когда он перестанет использоваться.
\item После связывания, сокет переводится в режим прослушивания (\texttt{listen()}). Число 5 позволяет размер очереди клиентов, желающих подключиться.
\item В бесконечном цикле, сервер ожидает подключения клиента. Исполнение процесса будет заблокировано на вызове \texttt{accept()}. Этот вызов позволяет позволяет получить копию исходного сокета, чтобы слушающий сокет был готов к получению запросов от других клиентов.
\item После этого снова в бесконечном цикле происходит получение и отправка сообщений длинной в 100 символов через копию сокета, полученного на предыдущем шаге.
\end{enumerate}

клиент:
\begin{enumerate}
\item Подобно серверу, создаётся сокет, используя системный вызов \texttt{socket()} с параметрами \texttt{AF\_UNIX} и \texttt{SOCK\_STREAM}.
\item На клиенте идёт подготовка к соединению. Обычно используется имя удалённого хоста и номер порта. Однако в нашем случае используется адрес сокета в файловой системе (адрес записывается в структуру \texttt{sockaddr\_un}).
\item Дальше следует непосредственно соединение (\texttt{connect()}).
\item В бесконечном цикле происходит считывание данных с устройства ввода (\texttt{stdin}), отправка их серверу, получение ответа от сервера и вывод этого ответа на стандартное устройство вывода (\texttt{stdout}).
\end{enumerate}

\textbf{Эксперимент:} Запуск сервера:
\begin{Verbatim}[frame=single,breaklines=true,breakanywhere=true]
    smart@thinkpad$ ./echo_server
    Waiting for a connection...
\end{Verbatim}

Запуск клиента:
\begin{Verbatim}[frame=single,breaklines=true,breakanywhere=true]
    smart@thinkpad$ ./echo_client
    Trying to connect...
    Connected.
    > 123
    echo> 123
    > test
    echo> test
    > тест
    echo> тест
    > ~!@#$%
    echo> ~!@#$%
    > 
\end{Verbatim}

После запуска сервера, в директории появляется файл сокета. Инормацию о нём можно получить, к примеру, с помощью утилиты \texttt{ss}.
\begin{Verbatim}[frame=single,breaklines=true,breakanywhere=true]
smart@thinkpad$ ss | grep echo_socket
u_str ESTAB    0      0               echo_socket 481033            * 481088
\end{Verbatim}
Эта запись означает следующее:
\begin{itemize}
    \item \texttt{u\_str} -- сетевой идентификатор;
    \item \texttt{ESTAB} -- состояние соединения;
    \item 0 -- количество пакетов в очереди на получение (\texttt{Recv-Q});
    \item 0 -- количество пакетов в очереди на отправку (\texttt{Send-Q});
    \item echo\_socket 481033 -- локальный адрес и порт (большое число для локальных соединений);
    \item $\ast{}$ 481088 -- адрес и порт клиента.
\end{itemize}

\section*{4. Интернет сокеты}
\addcontentsline{toc}{section}{4. Интернет сокеты}
\textbf{Задача:} Скомпилируйте c разными именами программы \texttt{sock\_c\_i\_srv.cpp} и \texttt{sock\_c\_i\_clt.cpp} (в них используется общий \texttt{include} файл \texttt{local\_c\_i.h}). Запустите программы сервера и клиента на разных терминалах. При запуске клиента указывайте в качестве параметра командной строки имя хоста \texttt{localhost}. Введите символьную информацию в окне клиента и поясните вывод.

Какой разновидности принадлежат сокеты, используемые в данном примере клиент-серверного взаимодействия?

\textbf{Ход решения:} Проведём анализ кода. Алгоритм практически аналогичен предыдущему примеру, но тут используется семейство \texttt{AF\_INET} и создание отдельных процессов для обслуживания клиентов. В данном примере, мы как и раньше используем потоковую передачу (\texttt{SOCK\_STREAM}), однако сетевые сокеты позволяют организовать передачу на датаграммах (\texttt{SOCK\_STREAM}) -- такие соединения работают без подтверждения факта доставки (\texttt{ACK}).

И сервер и клиент при вызове функции \texttt{socket()} используют константу \texttt{AF\_INET}, указывающую на то, что открываемый сокет должен быть сетевым. Сокеты в домене \texttt{AF\_INET}, не знают про то, что они работают на локальной системе и обращаются только к \texttt{localhost}. Они полностью выполняют все механизмы сетевого стека: переключения контекста, \texttt{ACK}, \texttt{TCP}, управление потоком, маршрутизацию, разбиение больших пакетов и т.п. То есть это «полноценная TCP работа» несмотря на то, что пакеты не покидают локального интерфейса.

Дополнительные издержки при использовании \texttt{AF\_INET} кроются так же в необходимости произвести резолвинг доменного имени в IP-адрес (вызов \texttt{gethostbyname()}) и решение проблемы little-big-end (вызов \texttt{htons()}, \texttt{htonl()}) связанной с разным порядком байтов на различных архитектурах (в комментариях кода написано что-то странное про "fake port").

Ещё одной особенность является обработка подключений клиентов в отдельных процессах. После установки соединения, сервер вызывает \texttt{fork()} и работает с каждым клиентом отдельно. Это значит, что каждый клиент получит в ответ только свои сообщения.

\textbf{Эксперимент:} запуск сервера.
\begin{Verbatim}[frame=single,breaklines=true,breakanywhere=true]
    smart@thinkpad$ ./sock_c_i_srv 
\end{Verbatim}

Запуск первого клиента.
\begin{Verbatim}[frame=single,breaklines=true,breakanywhere=true]
    smart@thinkpad$ ./sock_c_i_clt localhost
    > 1
    1
    > 2
    2
    > 3
    3
    > 
\end{Verbatim}

Запуск второго клиента.
\begin{Verbatim}[frame=single,breaklines=true,breakanywhere=true]
    smart@thinkpad$ ./sock_c_i_clt localhost
    > a
    A
    > b
    B
    > c
    C
    > d
    D
    > 
\end{Verbatim}

Замена строчных букв на заглавные происходит на стороне сервера при помощи команды \texttt{toupper(buf[i])}.

\section*{5. Модификация эхо-сервера}
\addcontentsline{toc}{section}{5. Модификация эхо-сервера}
\textbf{Задача:} Модифицируйте программу \texttt{echo\_server.cpp} так, чтобы при ответе на запросы клиента что-либо выводилось в окне сервера.

Испытайте работу эхо-сервера при работе с несколькими клиентами.

\textbf{Ход решения:}

Фактически, была добавлена только строчка 3, представленная в листинге 1.

\lstinputlisting[language=C++, caption={Фрагмент исходного кода модифицированного файла (echo\_server\_upd.cpp)}, firstline=69, lastline=79]
{../Tasks/1_Network_application/source_files/echo_server_upd.cpp}

\textbf{Эксперимент:} запуск сервера.
\begin{Verbatim}[frame=single,breaklines=true,breakanywhere=true]
    smart@thinkpad$ ./echo_server_upd 
    Waiting for a connection...
    Connected.
    [client 4] 1
    [client 4] 2
    [client 4] 3
    [client 4] 4
    Waiting for a connection...
    Connected.
    [client 4] a
    [client 4] b
    [client 4] c
    [client 4] d
\end{Verbatim}

Запуск первого клиента.
\begin{Verbatim}[frame=single,breaklines=true,breakanywhere=true]
    smart@thinkpad$ ./echo_client 
    Trying to connect...
    Connected.
    > 1
    echo> 1
    > 2
    echo> 2
    > 3
    echo> 3
    > 4
    echo> 4
    > ^C
\end{Verbatim}

Запуск второго клиента.
\begin{Verbatim}[frame=single,breaklines=true,breakanywhere=true]
    smart@thinkpad$ ./echo_client 
    Trying to connect...
    Connected.
    > a
    b
    c
    d
    echo> a
    > echo> b
    > echo> c
    > echo> d
    > 
\end{Verbatim}

Наблюдаемое поведение полностью в рамках ожиданий: когда сервер установил соединение с первым клиентом, он находится в заблокированном состоянии на операции сетевого обмена. Как только первый клиент завершает свою работу, мгновенно происходит подключение и обслуживание второго клиента (он даже получает тот-же номер файлового дескриптора). Отсюда напрашивается вывод, что работа слушающего сокета должна производиться в одном потоке, а обслуживающих -- в другом (других).

\section*{Выводы}
\addcontentsline{toc}{section}{Выводы}

В данной работе мы познакомились с основным набором системных вызовов для создания соединений различных типов. Использование протоколов семейства \texttt{AF\_INET} для локального подключения (\texttt{localhost}) оправдано только в том случае, если разработчик не знает откуда именно будет произведено подключение. Для взаимодействия в рамках одной системы следует предпочесть протоколы семейства \texttt{AF\_UNIX} и избежать всей накладной работы связанной с сетевым стеком.
